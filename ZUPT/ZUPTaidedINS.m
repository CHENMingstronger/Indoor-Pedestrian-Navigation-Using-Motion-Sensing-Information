%零速修正函数

%% 主函数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%@param[out]  x_h     位置、速度、航向角信息
%@param[out]  cov     状态协方差矩阵（对角元素）
%@param[in]   u      IMU的信息（加速度xyz，陀螺仪xyz）
%@param[in]   zupt    零速区间检测结果
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [x_h cov]=ZUPTaidedINS(u,zupt)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Initialize the data fusion          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%IMU数据长度
N=length(u);

%  初始化P矩阵
P = zeros( 9, 9, N);

%初始化滤波器状态协方差矩阵P，处理噪声
%协方差矩阵Q、伪测量噪声协方差R和观测矩阵H。
[P(:, :, 1), Q, R, H]=init_filter;          % init_filter的子函数在下面

% Allocate vecors
[x_h, cov, Id]=init_vec(N,P(:, :, 1));     % init_vec的子函数在下面

%初始化导航状态向量x_h和四元数向量quat。
[x_h(1:9,1), quat(:, 1)]=init_Nav_eq(u);  % init_Nav_eq的子函数在下面

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%        Run the filter algorithm          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for k=2:N

    %时间更新
    u_h = u(:, k);

    %更新导航方程
    [x_h(:,k), quat(:, k)]=Navigation_equations(x_h(:,k-1),u_h,quat(:, k-1)); 

    %更新状态转移矩阵
    [F, G]=state_matrix(quat(:, k),u_h); 


    %更新滤波器状态协方差矩阵P。
    P(:, :, k) = F*P(:, :, k - 1)*F' + G*Q*G';

    % 确保滤波器协方差矩阵对称
    P(:, :, k)=(P(:, :, k)+P(:, :, k)')/2;

    % 储存状态协方差矩阵
    cov(:,k)=diag(P(:, :, k));

    %零速区间修正
    if zupt(k)==true;
        %计算卡尔曼滤波增益K
        K=(P(:, :, k)*H')/(H*P(:, :, k)*H'+R);

        %计算预测误差。
        z=-x_h(4:6,k);

        %估计导航状态的扰动估计
        dx=K*z;

        %使用估计的扰动校正导航状态。
        [x_h(:,k) quat(:, k)]=comp_internal_states(x_h(:,k),dx,quat(:, k));     % Subfunction located further down in the file.


        % 更新滤波器状态协方差矩阵P
        P(:, :, k) = (Id - K*H)*P(:, :, k);

        %确保对称
        P(:, :, k) = (P(:, :, k) + P(:, :, k)')/2;

        %储存P矩阵
        cov(:,k) = diag(P(:, :, k));
    end
    
%     if zupt(k) == false;
%         x_h(:,k) = x_h(:,k) - cov(:,k);
%         
%     end
end

end



%% 子函数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%function[x_h cov Id]=初始向量（N，P）为零速度输出分配内存的简短函数辅助惯性导航算法。
%>
%>@param[out]x_h矩阵和估计的导航状态。
%>@param[out]cov矩阵，带有状态协方差矩阵的对角元素。
%>@param[out]Id身份矩阵。
%>@param[in]N IMU数据向量u的长度，即样本数。
%>@param[in]P初始状态协方差矩阵。
%>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [x_h, cov, Id]=init_vec(N,P)

global simdata

% Only the standard errors included
cov=zeros(9,N);
x_h=zeros(9,N);

Id=eye(size(P));
cov(:,1)=diag(P);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%function[x quat]=init_Nav_eq（u）
%
%>计算导航初始状态的简短函数
%>@param[out]x初始导航状态向量。
%>@param[out]四元数向量，表示平台的初始姿态。
%>@param[in]u矩阵和IMU数据。
%>
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [x, quat]=init_Nav_eq(u)

global simdata;
%假设系统在前20个样本期间处于静止状态，则根据前20个加速计读数计算初始横摇和纵摇。
f_u=mean(u(1,1:20));
f_v=mean(u(2,1:20));
f_w=mean(u(3,1:20));

roll=atan2(-f_v,-f_w);
pitch=atan2(f_u,sqrt(f_v^2+f_w^2));

%设置姿态向量
attitude=[roll pitch simdata.init_heading]';

%计算与初始姿态相对应的四元数
Rb2t=Rt2b(attitude)';
quat=dcm2q(Rb2t);  %

% Set the initial state vector
x=zeros(9,1);
x(1:3,1)=simdata.init_pos;
x(7:9,1)=attitude;
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%funtion [P Q R H]=init_filter()
%>初始化卡尔曼滤波器的简短函数
%>@param[out]P 初始状态协方差矩阵
%>@param[out]Q 处理噪声协方差矩阵
%>@param[out]R 测量噪声协方差矩阵
%>@param[out]H 测量观测矩阵
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [P Q R H]=init_filter

global simdata;
%状态协方差矩阵P
P=zeros(9);
%噪声协方差矩阵
Q=zeros(6);
%观测矩阵
H=zeros(3,9);
%观测矩阵H的一般值
H(1:3,4:6)=eye(3);

%初始协方差矩阵P的一般值
P(1:3,1:3)=diag(simdata.sigma_initial_pos.^2);
P(4:6,4:6)=diag(simdata.sigma_initial_vel.^2);
P(7:9,7:9)=diag(simdata.sigma_initial_att.^2);

%过程噪声协方差矩阵Q的一般值
Q(1:3,1:3)=diag(simdata.sigma_acc.^2);
Q(4:6,4:6)=diag(simdata.sigma_gyro.^2);

%测量噪声矩阵R的一般值
R=diag(simdata.sigma_vel.^2);

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%funtion [y,q]=Navigation_equations(x,u,q)
%>详细介绍了惯性导航系统的解算导航方程。
%>也就是说，该函数将导航系统的旧状态（位置、速度和姿态）与当前IMU数据测量值（比力、角速率）结合起来，并计算导航系统的当前状态。
%>@param[out]y新的导航状态[位置、速度、姿态（欧拉角]。
%>@param[out]q新四元数
%>@param[in]x旧导航状态
%>@param[in]u IMU数据[比力，角速率]。
%>@param[in]q旧四元数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [y,q]=Navigation_equations(x,u,q)

global simdata;

%为输出向量分配内存
y=zeros(size(x));

%采样频率
Ts=simdata.Ts;

%*************************************************************************%
%根据角速率测量值更新四元数向量“q”。
%*************************************************************************%

w_tb=u(4:6);

P=w_tb(1)*Ts;
Q=w_tb(2)*Ts;
R=w_tb(3)*Ts;

OMEGA=zeros(4);

OMEGA(1,1:4)=0.5*[0 R -Q P];
OMEGA(2,1:4)=0.5*[-R 0 P Q];
OMEGA(3,1:4)=0.5*[Q -P 0 R];
OMEGA(4,1:4)=0.5*[-P -Q -R 0];
% OMEGA(1,1:4)=0.5*[0 -P -Q -R];
% OMEGA(2,1:4)=0.5*[P 0 R -Q];
% OMEGA(3,1:4)=0.5*[Q -R 0 P];
% OMEGA(4,1:4)=0.5*[R Q -P 0];

v=norm(w_tb)*Ts;

if v~=0
    q=(cos(v/2)*eye(4)+2/v*sin(v/2)*OMEGA )*q;
    q=q./norm(q);
end

%*************************************************************************%
%使用更新四元数以欧拉角的形式获取导航系统的姿态。
%*************************************************************************%

%获得滚转、俯仰和偏航
Rb2t=q2dcm(q);
%滚转
y(7)=atan2(Rb2t(3,2),Rb2t(3,3));

%俯仰
%y(8)= atan(- Rb2t(3,1)/sqrt(Rb2t(3, 2)^2 + Rb2t(3,3)^2));
y(8)= atan(- Rb2t(3,1));
% reference: http://planning.cs.uiuc.edu/node103.html

%偏航
y(9)=atan2(Rb2t(2,1),Rb2t(1,1));


%*************************************************************************%
%使用测量的特定力和新计算的姿态更新位置和速度状态。
%*************************************************************************%

%重力加速度
g_t=[0 0 simdata.g]';

%将特定力向量转换为导航坐标系。
f_t=q2dcm(q)*u(1:3);

%减去（加上）重力，以获得导航坐标系中的加速度。
acc_t=f_t+g_t;

%状态空间模型矩阵
A=eye(6);
A(1,4)=Ts;
A(2,5)=Ts;
A(3,6)=Ts;

B=[(Ts^2)/2*eye(3);Ts*eye(3)];

%更新位置和速度
y(1:6)=A*x(1:6)+B*acc_t;
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function[F G]=状态矩阵（q，u）
%>用于计算状态转移矩阵F和过程噪声增益矩阵G，给定平台的当前方向和特定力向量。
%>
%>param[out]F 状态转移矩阵。
%>param[out]G 过程噪声增益矩阵。
%>param[in]u IMU数据[比力，角速率]。
%>param[in]q 旧四元数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [F, G]=state_matrix(q,u)

global simdata

%四元数转换为旋转矩阵
Rb2t=q2dcm(q);

%将测量坐标系转换为导航坐标系。
f_t=Rb2t*u(1:3);

%创建特定前向量的ske对称矩阵
%这是一个向量积矩阵
St=[0 -f_t(3) f_t(2); f_t(3) 0 -f_t(1); -f_t(2) f_t(1) 0];

%0矩阵
O=zeros(3);

%单位矩阵
I=eye(3);

% 转换矩阵
    Fc=[O I O;
        O O St;
        O O O];

% 噪声增益矩阵
    Gc=[O O; Rb2t O; O -Rb2t];
%离散时间-状态转移矩阵的逼近
F=eye(size(Fc))+simdata.Ts*Fc;
G=simdata.Ts*Gc;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function[x_out q_out]=复合内部状态（x_in，dx，q_in）
%
%>通过卡尔曼滤波器估计的系统扰动（误差）校正估计的导航状态的简短功能。
%>
%>函数，通过卡尔曼滤波器估计的系统扰动（误差）校正估计的导航状态。
%>也就是说，通过将估计的系统扰动添加到这些状态中，来校正导航平台的当前位置和速度估计。
%>为了校正方向状态（欧拉角和四元数向量），首先将四元数向量转换为旋转矩阵，然后使用估计的方向扰动进行校正。
%>然后将修正后的旋转矩阵转换回四元数向量，以及欧拉角的等效向量。
%>@param[out]x_out校正（后验）导航状态向量。
%>@param[out]q_out校正（后验）四元数向量。
%>@param[in]x_在先验估计的导航状态向量中。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [x_out, q_out]=comp_internal_states(x_in,dx,q_in)

%将四元数转换为旋转矩阵
R=q2dcm(q_in);

%修正状态向量
x_out=x_in+dx;

%修正旋转矩阵
epsilon=dx(7:9);
OMEGA=[0 -epsilon(3) epsilon(2); epsilon(3) 0 -epsilon(1); -epsilon(2) epsilon(1) 0];
R=(eye(3)-OMEGA)*R;

%从修正的旋转矩阵中获得修正的横滚、俯仰和航向
x_out(7)=atan2(R(3,2),R(3,3));
x_out(8)=atan(-R(3,1)/sqrt(R(3,2)^2+ R(3,3)^2));
x_out(9)=atan2(R(2,1),R(1,1));

% 计算修正后的四元数
q_out=dcm2q(R);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=q2dcm(q)
%四元数转换为方向余弦矩阵
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function R=q2dcm(q)

p=zeros(6,1);

p(1:4)=q.^2;

p(5)=p(2)+p(3);

if p(1)+p(4)+p(5)~=0
   p(6)=2/(p(1)+p(4)+p(5));
else
   p(6)=0;
end


R(1,1)=1-p(6)*p(5);
R(2,2)=1-p(6)*(p(1)+p(3));
R(3,3)=1-p(6)*(p(1)+p(2));

p(1)=p(6)*q(1);
p(2)=p(6)*q(2);
p(5)=p(6)*q(3)*q(4);
p(6)=p(1)*q(2);

R(1,2)=p(6)-p(5);
R(2,1)=p(6)+p(5);

p(5)=p(2)*q(4);
p(6)=p(1)*q(3);

R(1,3)=p(6)+p(5);
R(3,1)=p(6)-p(5);

p(5)=p(1)*q(4);
p(6)=p(2)*q(3);

R(2,3)=p(6)-p(5);
R(3,2)=p(6)+p(5);

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function q=dcm2q（R）
%>将方向余弦矩阵（旋转矩阵）转换为四元数向量的简短函数。
%>@param[out]q四元数向量。
%>@param[in]R旋转矩阵。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function q=dcm2q(R)

T = 1 + R(1,1) + R(2,2) + R(3,3);

if T > 10^-8

    S = 0.5 / sqrt(T);
    qw = 0.25 / S;
    qx = ( R(3,2) - R(2,3) ) * S;
    qy = ( R(1,3) - R(3,1) ) * S;
    qz = ( R(2,1) - R(1,2) ) * S;

else

    if (R(1,1) > R(2,2)) && (R(1,1) > R(3,3))

        S = sqrt( 1 + R(1,1) - R(2,2) - R(3,3)) * 2; % S=4*qx
        qw = (R(3,2) - R(2,3)) / S;
        qx = 0.25 * S;
        qy = (R(1,2) + R(2,1)) / S;
        qz = (R(1,3) + R(3,1)) / S;

    elseif (R(2,2) > R(3,3))

        S = sqrt( 1 + R(2,2) - R(1,1) - R(3,3) ) * 2; %S=4*qy
        qw = (R(1,3) - R(3,1)) / S;
        qx = (R(1,2) + R(2,1)) / S;
        qy = 0.25 * S;
        qz = (R(2,3) + R(3,2)) / S;

    else

        S = sqrt( 1 + R(3,3) - R(1,1) - R(2,2) ) * 2; % S=4*qz
        qw = (R(2,1) - R(1,2)) / S;
        qx = (R(1,3) + R(3,1)) / S;
        qy = (R(2,3) + R(3,2)) / S;
        qz = 0.25 * S;

    end

end

q = [qx qy qz qw]';
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function R=Rt2b（ang）
%>该函数计算旋转矩阵，以便在给定欧拉角向量的情况下，将向量从坐标系t旋转到坐标系b。
%>@param[out]R旋转矩阵。
%>@param[in] ang Euler角[横滚、俯仰、航向]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function R=Rt2b(ang)


cr=cos(ang(1));
sr=sin(ang(1));

cp=cos(ang(2));
sp=sin(ang(2));

cy=cos(ang(3));
sy=sin(ang(3));

R=[cy*cp sy*cp -sp;
    -sy*cr+cy*sp*sr cy*cr+sy*sp*sr cp*sr;
    sy*sr+cy*sp*cr -cy*sr+sy*sp*cr cp*cr];

end
