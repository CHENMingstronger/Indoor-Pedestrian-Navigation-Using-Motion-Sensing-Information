%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%funtion [y,q]=Navigation_equations(x,u,q)
%>详细介绍了惯性导航系统的解算导航方程。
%>也就是说，该函数将导航系统的旧状态（位置、速度和姿态）与当前IMU数据测量值（比力、角速率）结合起来，并计算导航系统的当前状态。
%>@param[out]y新的导航状态[位置、速度、姿态（欧拉角]。
%>@param[out]q新四元数
%>@param[in]x旧导航状态
%>@param[in]u IMU数据[比力，角速率]。
%>@param[in]q旧四元数
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [y,q]=Navigation_equations(x,u,q)

global simdata;

%为输出向量分配内存
y=zeros(size(x));

%采样频率
Ts=simdata.Ts;

%*************************************************************************%
%根据角速率测量值更新四元数向量“q”。
%*************************************************************************%

w_tb=u(4:6);

P=w_tb(1)*Ts;
Q=w_tb(2)*Ts;
R=w_tb(3)*Ts;

OMEGA=zeros(4);

OMEGA(1,1:4)=0.5*[0 R -Q P];
OMEGA(2,1:4)=0.5*[-R 0 P Q];
OMEGA(3,1:4)=0.5*[Q -P 0 R];
OMEGA(4,1:4)=0.5*[-P -Q -R 0];
% OMEGA(1,1:4)=0.5*[0 -P -Q -R];
% OMEGA(2,1:4)=0.5*[P 0 R -Q];
% OMEGA(3,1:4)=0.5*[Q -R 0 P];
% OMEGA(4,1:4)=0.5*[R Q -P 0];

v=norm(w_tb)*Ts;

if v~=0
    q=(cos(v/2)*eye(4)+2/v*sin(v/2)*OMEGA )*q;
    q=q./norm(q);
end

%*************************************************************************%
%使用更新四元数以欧拉角的形式获取导航系统的姿态。
%*************************************************************************%

%获得滚转、俯仰和偏航
Rb2t=q2dcm(q);
%滚转
y(7)=atan2(Rb2t(3,2),Rb2t(3,3));

%俯仰
%y(8)= atan(- Rb2t(3,1)/sqrt(Rb2t(3, 2)^2 + Rb2t(3,3)^2));
y(8)= atan(- Rb2t(3,1));
% reference: http://planning.cs.uiuc.edu/node103.html

%偏航
y(9)=atan2(Rb2t(2,1),Rb2t(1,1));


%*************************************************************************%
%使用测量的特定力和新计算的姿态更新位置和速度状态。
%*************************************************************************%

%重力加速度
g_t=[0 0 simdata.g]';

%将特定力向量转换为导航坐标系。
f_t=q2dcm(q)*u(1:3);

%减去（加上）重力，以获得导航坐标系中的加速度。
acc_t=f_t+g_t;

%状态空间模型矩阵
A=eye(6);
A(1,4)=Ts;
A(2,5)=Ts;
A(3,6)=Ts;

B=[(Ts^2)/2*eye(3);Ts*eye(3)];

%更新位置和速度
y(1:6)=A*x(1:6)+B*acc_t;
end
